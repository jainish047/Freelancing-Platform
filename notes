Feature	                       |state.stateName (in reducers)	       |getState() (in async thunks)
-------------------------------+---------------------------------------+-----------------------------
Where can it be used?	       |Only inside "createSlice reducers"	   |Inside "async thunks" (createAsyncThunk)
What can it access?	           |Only its own slice (projectFilter)	   |The full Redux store (projectFilter, user, notifications, etc.)
Can it modify state?	       |✅ Yes, directly modifies state	      |❌ No, read-only
Can it be used asynchronously? |❌ No, reducers must be synchronous	  |✅ Yes, used inside async functions

--> immer and Immutable State in Redux
    Immer is a library used internally by Redux Toolkit (via the createSlice API) to automatically handle immutability for you.
    Reducers in Redux must follow immutable patterns, meaning you cannot directly mutate the state.
    With Immer (which is used by default in createSlice), you can "mutate" the state as if it's mutable, but behind the scenes, it keeps the state immutable.

    ex:
        reducers: {
            updateSearchString: (state, action) => {
                state.searchString = action.payload; // "Mutating" state is okay with Immer
            },
        },
    ~> Even though the state looks like it's being mutated directly, Immer ensures the original state is not changed. It produces a new copy of the state with the modifications, keeping the integrity of Redux's immutability principle.

--> extraReducers
    Used when you want to handle actions that were not generated by createSlice itself.
    It's often used with async thunks or other actions that don't belong directly to the slice but still need to update its state.
    extraReducers is often used to listen to actions outside the slice.
    It does not define new reducers but extends them to handle external actions.


--> createSlice vs. createReducer
    createSlice():
        A higher-level abstraction that automatically generates action creators and reducers.
        The reducer logic is usually more declarative and straightforward.
        Preferred for most cases, as it integrates easily with Redux Toolkit and simplifies common patterns.

    createReducer():
        createReducer is used for defining reducers to update state based on actions.
        Allows more control over reducers.
        Works similarly to createSlice but does not generate actions automatically.
        With createReducer, you manually define your action types and map them to reducers as action(key) to reducer(value).

        ex:
            => define
            const projectFilterReducer = createReducer(initialState, {
                'projectFilter/updateSearchString': (state, action) => {
                    state.searchString = action.payload;
                },
                'projectFilter/setStatus': (state, action) => {
                    state.status = action.payload;
                },
            });

            => call
                1. with action defined
                    -> action creation
                    import { createAction } from '@reduxjs/toolkit';
                    export const updateSearchString = createAction('projectFilter/updateSearchString');

                    -> dispatch action
                    dispatch(updateSearchString(newSearchString));

                2. without action defined
                    dispatch({
                        type: 'projectFilter/updateSearchString',  // This matches the action type in the reducer
                        payload: newSearchString,  // The payload that will be processed in the reducer
                    });


--> for reducers
    (state, payload)=>{
        state.status = action.payload;
        // here considering payload contains new value of state
        // btw it can be anything (object also possible)
    }

--> createAsyncThunk
    createAsyncThunk is a utility for handling asynchronous operations in Redux Toolkit, and it automatically dispatches actions like pending, fulfilled, and rejected based on the state of the promise.

    1. Callback function in createAsyncThunk:
        The callback function inside createAsyncThunk is a payload creator. It takes two arguments:

        => The first argument is _ (it's common to use _ when the argument isn't needed). This is where you'd pass any parameters for the asynchronous operation (in this case, filters), but since you're not passing any arguments when dispatching this thunk, it's left as _.
        => The second argument is an object that provides several helpers, including:
            getState:           A function that allows you to access the current state from the Redux store. This is where you get the filters from getState().projectFilter.
            rejectWithValue:    A function that you use to return an error payload in case the async operation fails. This helps in handling errors when the promise is rejected, and the error message can be passed back as the payload.
        The callback function in createAsyncThunk is where you perform your async operations (like making an API call), and you get access to dispatch, getState, and rejectWithValue to manage the flow based on success or failure.

--> Flow

    1. Action Creator (from slice):
        When you define actions using createSlice, Redux Toolkit automatically generates action creators for each of the reducers defined within that slice. 
        These action creators are functions that return action objects with a 'type' and optional 'payload'.
        You define an action creator (updateFilters) in your slice:
        
        export const { updateFilters } = projectFilterSlice.actions;

    2. Dispatching the Action: In a component, you dispatch the updateFilters action:

        dispatch(updateFilters({ searchString: 'New Search Term' }));
        // reducer (call) updateFilters({ searchString: 'New Search Term' }) return action objects with a 'type' and optional 'payload'.

    3. The Reducer (from slice):
        The dispatched action will reach the updateFilters reducer, which modifies the state:

        -> defined like
        reducers: {
            updateFilters: (state, action) => {
                state.searchString = action.payload.searchString;
            },
        }

    4. Updating the Store:
        The reducer updates the state in the Redux store. The store now holds the updated state.

--> key points
Reducers:   Functions that define how state changes. They are part of the slice, but they don't directly store state.
State:      Defined as initialState inside each slice, and this is what gets stored in the Redux store.
Store:      The Redux store holds the application state, which is the collection of all slices' states.
    
    - When an action is dispatched, the Redux store is responsible for passing the action to the appropriate reducer. To do this, the store uses a reducer map (also known as the root reducer) to figure out which reducer should handle the action.
    - The store will look at the action's type and match it to the appropriate reducer. The type property in the action determines which slice’s reducer will handle it.
        If you dispatch an action with the type 'projectFilter/updateSearchString', the store will know to pass it to the projectFilterSlice.reducer.
        If you dispatch an action like 'loading/setLoadingState', it will be routed to the loadingSlice.reducer.